PSEUDOCODE: Family Tree Viewer Application

OBJECTIVE:
    Visualize a family tree from a CSV file using a Win32 GUI application (C++).
    Support multiple spouses, ex-spouses, automatic layout, and hot-reloading.

0. IMPLEMENTATION NOTES (CRITICAL FOR GENERATION)
    *   Language: C++ (Standard + Win32 API).
    *   Encoding: UNICODE (_UNICODE) is mandatory for modern Windows text.
    *   Resource Management: Use RAII wrappers for GDI objects (Pens, Brushes, Fonts) to prevent resource leaks. DO NOT use raw SelectObject without restoring the original.
    *   Memory: Use std::vector, std::map, std::wstring. Avoid raw C-arrays.
    *   Graphics: Use GDI (Graphics Device Interface). Use SetWorldTransform for scrolling.

1. DATA STRUCTURES & CONFIGURATION

    CONSTANT CONFIG:
        Dimensions: 
            BoxWidth=200, BoxHeight=75
            VerticalGap=150, HorizontalGap=50, SpouseGap=25
        Colors (RGB): 
            Canvas=(250,250,252)
            BoxDefault=(255,255,255), BoxFemale=(255,245,248), BoxFocus=(255,252,220)
            LineChild=(180,180,180), LineSpouse=(220,80,80), LineEx=(220,80,80)

    STRUCTURE Person:
        Integer: ID
        String: Name, Role, Gender
        Integer: FatherID, MotherID
        Vector<Integer>: Spouses       // List of spouse IDs
        Set<Integer>: ExSpouses        // Subset of IDs marked as 'ex'
        
        // Visualization Fields (Initialized to -10000)
        Integer: X, Y 
        Integer: GenerationLevel

2. MAIN APPLICATION FLOW

    FUNCTION WinMain:
        Initialize Window Class (background brush, icon, cursor)
        Create Main Window "Family Tree Viewer" (WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL)
        Initialize Application State (Load Data immediately)
        SetTimer(1000ms) for Hot-Reloading
        Start Message Loop (GetMessage -> Translate -> Dispatch)

    FUNCTION WindowProcedure (Event Handler):
        SWITCH Message:
            CASE WM_CREATE:
                Call App.Init()
            CASE WM_TIMER:
                Check File LastWriteTime. If changed -> ReloadData() -> InvalidateRect()
            CASE WM_PAINT:
                Call App.OnPaint()
            CASE WM_SIZE:
                UpdateScrollBars()
            CASE WM_VSCROLL / WM_HSCROLL:
                Call App.OnScroll()
            CASE WM_DESTROY:
                PostQuitMessage(0)

3. DATA LOADING (DataModel)

    FUNCTION LoadFromFile(FilePath):
        Clear existing People list and ID Map
        Open FilePath using wide-char stream
        Check for and Skip BOM (Byte Order Mark)
        Skip Header Line
        
        WHILE Read Line from File:
            Parse CSV Columns -> ID, Name, Role, Gender, FatherID, MotherID, SpouseString
            
            Create Person P
            Assign Basic Fields
            
            // Parse Spouses (Format: "101x|102")
            Split SpouseString by '|'
            FOR EACH Token:
                IsEx = Check suffix 'x' or 'X'
                CleanID = Remove suffix
                ID = ParseInt(CleanID)
                If ID != 0:
                    Add ID to P.Spouses
                    If IsEx: Add ID to P.ExSpouses
            
            Add P to People Vector
            Update Map: ID -> VectorIndex

4. LAYOUT ALGORITHM (LayoutEngine)

    FUNCTION RecalculateLayout:
        Reset all X, Y to -10000
        Clear subtree caches
        
        // Step 1: Generation Assignment
        Loop (Max 20 Iterations or until stable):
            For each Person P:
                Gen = Max(Father.Gen, Mother.Gen) + 1
                If Parents Unknown:
                    Try to inherit Gen from Spouses
                    If no Spouses have Gen: Gen = 0 (Root)
        
        // Step 2: Cluster/Leader Assignment (Graph linearization)
        // Goal: Assign every node to exactly one "Root Family" to prevent duplicates
        Initialize NodeOwner Map
        For each Person P where Gen == 0:
            // "Leader" Check: Am I the canonical root of this marriage?
            SmallestID = Min(P.ID, All Spouses IDs)
            IF P.ID == SmallestID:
                Run BFS(StartNode=P)
                Mark P, Spouses, and All Descendants as "Owned" by P.ID
        
        // Step 3: Positioning
        CurrentX = 50, CurrentY = 50
        PlacedSet = Empty
        
        FOR EACH Person P in Model:
            // Only layout if P is a Root Leader
            IF P.Gen == 0 AND NodeOwner[P.ID] == P.ID:
                
                // Smart Gapping
                If PlacedSet is not empty:
                     IsRelated = Check if P connects to anyone in PlacedSet
                     Gap = IsRelated ? HorizontalGap : (HorizontalGap * 0) // or 0 for separate trees
                     CurrentX += Gap
                
                CalculateSubtreeWidth(P.ID)
                PositionSubtree(P.ID, CurrentX, CurrentY)
                
                CurrentX += SubtreeWidth(P.ID)
        
        Finalize Scroll Dimensions (Max X, Max Y)

    FUNCTION CalculateSubtreeWidth(PersonID):
        // Memoized Post-Order Traversal
        IF Memoized Return CachedValue
        
        Person = Get(PersonID)
        NumSpouses = Length(Person.Spouses)
        
        // Width A: Parents Cluster
        // [Spouse][Gap][Me][Gap][Spouse]
        ParentsWidth = (BoxWidth * (1 + NumSpouses)) + (SpouseGap * NumSpouses)
        
        // Width B: Children Cluster
        Children = GetSortedChildren(PersonID)
        ChildrenWidth = Sum(CalculateSubtreeWidth(Child) for Child in Children)
        If Children > 0: ChildrenWidth += (Children.Count - 1) * HorizontalGap
        
        TotalWidth = Max(ParentsWidth, ChildrenWidth)
        Cache TotalWidth
        Return TotalWidth

    FUNCTION PositionSubtree(PersonID, CenterX, Y):
        // Recursive Pre-Order Traversal
        IF Already Placed OR Owner Mismatch Return
        Mark as Placed
        
        Person = Get(PersonID)
        
        // 1. Position Parents Cluster (Centered at CenterX)
        ParentsWidth = (BoxWidth * (1 + NumSpouses)) + (SpouseGap * NumSpouses)
        StartX = CenterX - (ParentsWidth / 2)
        
        // A. Left Spouses
        NumLeft = NumSpouses / 2
        For i = 0 to NumLeft - 1:
            Spouse = Get(Person.Spouses[i])
            Spouse.X = StartX, Spouse.Y = Y
            Mark Spouse Placed
            StartX += BoxWidth + SpouseGap

        // B. Main Person
        Person.X = StartX, Person.Y = Y
        StartX += BoxWidth + SpouseGap

        // C. Right Spouses
        For i = NumLeft to NumSpouses - 1:
            Spouse = Get(Person.Spouses[i])
            Spouse.X = StartX, Spouse.Y = Y
            Mark Spouse Placed
            StartX += BoxWidth + SpouseGap

        // 2. Position Children
        Children = GetSortedChildren(PersonID)
        IF No Children Return
        
        ChildrenTotalWidth = Sum(SubtreeWidths) + Gaps
        CurrentChildX = CenterX - (ChildrenTotalWidth / 2)
        
        FOR EACH Child in Children:
            ChildW = GetSubtreeWidth(Child)
            // Center the child's subtree in its allocated slot
            ChildCenterX = CurrentChildX + (ChildW / 2)
            
            PositionSubtree(Child, ChildCenterX, Y + VerticalGap)
            
            CurrentChildX += ChildW + HorizontalGap

    FUNCTION GetSortedChildren(PersonID):
        // Heuristic Sort to minimize line crossing
        // Group children by which spouse is the *other* parent.
        // Map SpouseID -> Index (0, 1, 2...)
        //
        // Sort Key Calculation for Child C:
        //   OtherParent = (C.Father == PersonID) ? C.Mother : C.Father
        //   If OtherParent is Left Spouse:  Key < Middle
        //   If OtherParent is Right Spouse: Key > Middle
        //   If Single Parent: Key = Middle
        
        Return Sorted Children IDs

5. RENDERING SYSTEM (Renderer)

    FUNCTION DrawTree(HDC, DataModel):
        Draw Title "My Family Tree"
        
        // Layer 1: Connectors (Draw First)
        FOR EACH Person P where P.X > ValidMin:
            // Spouse Lines
            FOR EACH SpouseID:
                Spouse = Get(SpouseID)
                If Spouse.X > ValidMin:
                    SetPen(Spouse.Ex ? DOT : SOLID, Spouse.Ex ? GRAY : RED)
                    DrawLine(P.Center, Spouse.Center)
                    
                    // Children Drop Line
                    Children = GetChildrenSharedBy(P, Spouse)
                    If Children:
                        MidX = (P.X + Spouse.X) / 2 + BoxWidth/2 + Gap/2
                        DrawLine(MidX, P.Y+Height/2) to (MidX, P.Y+Height/2 + 30)
                        For each Child:
                            DrawOrthogonalLine to Child.TopCenter

            // Single Parent Lines
            IF No Spouses:
                Children = GetSingleParentChildren(P)
                DrawLine from P.BottomCenter to Child.TopCenter

        // Layer 2: Boxes (Draw Second)
        FOR EACH Person P where P.X > ValidMin:
            DrawShadowRect(P.X+4, P.Y+4)
            DrawFilledRect(P.X, P.Y, Color=Gender/NameCheck)
            DrawBorder
            DrawText(P.Name, Bold, TopHalf)
            DrawText(P.Role, Regular, BottomHalf)
            
        DrawLegend()

6. SCROLLING & INTERACTIVITY

    FUNCTION OnPaint(HWND):
        PAINTSTRUCT ps
        HDC hdc = BeginPaint()
        
        // Double Buffering Setup
        HDC memDC = CreateCompatibleDC(hdc)
        HBITMAP memBM = CreateCompatibleBitmap(hdc, ClientWidth, ClientHeight)
        SelectObject(memDC, memBM)
        
        FillRect(memDC, White)
        
        // Apply Scroll Transform
        SetGraphicsMode(memDC, GM_ADVANCED)
        XFORM form = {1, 0, 0, 1, -ScrollX, -ScrollY}
        SetWorldTransform(memDC, &form)
        
        Renderer.DrawTree(memDC, DataModel)
        
        // Reset Transform for Static UI (Legend)
        ModifyWorldTransform(Identity)
        Renderer.DrawLegend(memDC)
        
        // Blit to Screen
        BitBlt(hdc, 0, 0, Width, Height, memDC, 0, 0, SRCCOPY)
        
        Cleanup(memDC, memBM)
        EndPaint()
